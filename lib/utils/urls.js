/**
 * This file is part of the Firefox extension "CoopFox", developed as part of my master's thesis
 * at the Cooperative Media Lab, University of Bamberg, Germany.
 * @copyright (c) 2014 Ralf Strobel
 *
 * All content is no longer maintained and is made available purely for archival and educational purposes.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

'use strict';

const { md5 } = require('./strings');

const urlPattern = new RegExp(
    '^(\\w+)://' + // schema
        '(?:([^@]+)@)?'  + // login
        '([^/]+)' + // host + port
        '([^\\?]*)' + // path
        '(?:\\?([^#]+))?' + // query string
        '(?:#(.*))?$' // fragment
);

const cleanPatterns = [
    /#[^=&\^\[\]\\\/"<>]*$/, //only remove plain fragments, some sites use them to pass js parameters
    /(?:&(?:amp;)?)?PHPSESSID=[^&#]*/
];

const hashCleanPatterns = [
    [/^https:\/\//i, 'http://'],
    [/^http:\/\/(?:www\.)?(amazon\.[a-z]{2,4}).*?\/(?:dp|gp\/product)\/([a-zA-Z0-9]{10})\/.*$/, 'http://$1/dp/$2'],
    [/^http:\/\/(?:(?:www\.)?youtube\.com\/.*?v=|youtu.be\/|y2u.be\/)([^&]+).*$/, 'http://www.youtube.com/watch?v=$1']
];

const cleanUrlCache = {};
const urlHashCache = {};

/**
 * Splits a URL into its parts (scheme, login, host, path, query, fragment).
 *
 * @param {string} url
 * @returns {object}
 */
function splitUrl(url) {
    if (typeof(url) !== 'string') { return null; }
    var parts = url.match(urlPattern);
    if (!parts) {
        return null;
    }
    return {
        scheme: parts[1],
        login: parts[2] || '',
        host: parts[3],
        path: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
    };
}
exports.splitUrl = splitUrl;

/**
 * Composes a url from parts, as generated by splitUrl().
 *
 * @param {object} parts
 * @returns {string}
 */
function joinUrl(parts) {
    var url = parts.scheme + '://';
    if (parts.login) {
        url += parts.login + '@';
    }
    url += parts.host + parts.path;
    if (parts.query) {
        url += '?' + parts.query;
    }
    if (parts.fragment) {
        url += '#' + parts.fragment;
    }
    return url;
}
exports.joinUrl = joinUrl;

/**
 * Alternative implementation to sdk/querystring,
 * which only decodes on request and is generally more syntax-tolerant.
 *
 * @param {string} query
 * @param {bool} decode
 * @returns {object}
 */
function parseQueryString(query, decode) {
    if (typeof(query) !== 'string') { return null; }
    var result = {};
    if (!query.length) { return result; }

    for each (let chunk in query.split(/&(?:amp;)?/)) {
        let pair = chunk.split('=');
        let key = decode ? decodeURIComponent(pair[0]) : pair[0];
        let value = decode ? decodeURIComponent(pair.slice(1).join('=')) : pair.slice(1).join('=');

        if (!(key in result)) {
            result[key] = value;
        }
        else if (Array.isArray(result[key])) {
            result[key].push(value);
        }
        else {
            result[key] = [value];
        }
    }

    return result;
}
exports.parseQueryString = parseQueryString;

/**
 * Alternative implementation to sdk/querystring,
 * which only encodes on request and is generally more syntax-tolerant.
 *
 * @param {object} parts
 * @param {bool} encode
 * @returns {string}
 */
function joinQueryString(parts, encode) {
    var result = [];
    for (let key in parts) {
        if (encode) {
            key = encodeURIComponent(key);
        }
        let value = parts[key];
        if (!Array.isArray(value)) {
            value = [value];
        }
        for each (let val in value) {
            if (encode) {
                val = encodeURIComponent(val);
            }
            result.push(key + '=' + val);
        }
    }
    return result.join('&');
}
exports.joinQueryString = joinQueryString;

function applyCleanPatterns(url, patterns) {
    for each (let pattern in patterns) {
        let replacement = '';
        if (Array.isArray(pattern)) {
            replacement = pattern[1];
            pattern = pattern[0];
        }
        url = url.replace(pattern, replacement);
    }
    return url;
}

/**
 * Removes REST-irelevant and security-problematic parts from a URL.
 * Most commonly this is the fragment, unless it contains a query,
 * as well as the php session id.
 *
 * The resulting url should be safe to transmit to other clients.
 *
 * @param {string} url
 * @returns {string}
 */
function cleanUrl(url) {
    if (typeof(url) !== 'string') { return url; }
    var cleanurl = cleanUrlCache[url];
    if (!cleanurl) {
        cleanurl = cleanUrlCache[url] = applyCleanPatterns(url, cleanPatterns);
    }
    return cleanurl;
}
exports.cleanUrl = cleanUrl;

/**
 * Generates a short hash string for a URL.
 * URLs are cleaned more aggressively before hashing to extend comparability.
 *
 * @param {string} url
 * @returns {string}
 */
function urlHash(url) {
    if (typeof(url) !== 'string') { return url; }
    var hash = urlHashCache[url];
    if (!hash) {
        let cleanurl = applyCleanPatterns(cleanUrl(url), hashCleanPatterns);
        hash = urlHashCache[url] = md5(cleanurl);
        //console.log('URLHash: ' + url + ' > ' + cleanurl + ' > ' + hash);
    }
    return hash;
}
exports.urlHash = urlHash;